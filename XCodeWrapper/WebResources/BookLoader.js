import { debugLog } from "./DebugConfig.js";

/**
 * BookLoader - Handles loading books from files or directories
 *
 * When a book is loaded, automatically passes it to FoliateManager
 */
export default class BookLoader {
  #foliateManager;

  constructor(foliateManager) {
    this.#foliateManager = foliateManager;
    debugLog("BookLoader", "Initialized");
  }

  /**
   * Load and open a book from a file path
   * Non-async wrapper for Swift to call - kicks off loading and returns immediately
   */
  openBook(filePath) {
    debugLog("BookLoader", "openBook() called with path:", filePath);
    this.#loadBookFromFile(filePath)
      .then(file => this.#foliateManager.open(file))
      .catch(err => console.error("[BookLoader] Failed to load book:", err));
  }

  /**
   * Load and open a book from a directory
   * Non-async wrapper for Swift to call - kicks off loading and returns immediately
   */
  openBookFromDirectory(dirPath) {
    debugLog("BookLoader", "openBookFromDirectory() called with path:", dirPath);
    this.#loadBookFromDirectory(dirPath)
      .then(book => this.#foliateManager.open(book))
      .catch(err => console.error("[BookLoader] Failed to load book from directory:", err));
  }

  /**
   * Load a book from a file path (internal async method)
   */
  async #loadBookFromFile(filePath) {
  debugLog("trace", "loadBookFromFile trace");
  try {
    debugLog("BookLoader", "Starting to load file:", filePath);

    const fetchUrl = new URL(filePath, import.meta.url);
    debugLog("BookLoader", "Fetch URL:", fetchUrl.href);

    const fetchPromise = fetch(fetchUrl).catch(err => {
      console.error("[BookLoader] Fetch threw error:", err);
      console.error("[BookLoader] Error type:", err.name);
      console.error("[BookLoader] Error message:", err.message);
      throw new Error(`Fetch error: ${err.message}`);
    });
    const timeoutPromise = new Promise((_, reject) =>
      setTimeout(() => reject(new Error("Fetch timeout after 30s")), 30000)
    );

    debugLog("BookLoader", "Starting fetch...");
    const response = await Promise.race([fetchPromise, timeoutPromise]);
    debugLog("BookLoader", "Fetch completed, status:", response.status, "ok:", response.ok);

    if (!response.ok && response.status !== 0) {
      throw new Error(`Fetch failed with status ${response.status}`);
    }

    const contentLength = response.headers.get('content-length');
    debugLog("BookLoader", "Content-Length:", contentLength, "bytes",
                contentLength ? `(${(contentLength / 1024 / 1024).toFixed(2)} MB)` : "");

    debugLog("BookLoader", "Converting response to blob...");
    const blobPromise = response.blob();
    const blobTimeoutPromise = new Promise((_, reject) =>
      setTimeout(() => reject(new Error("Blob conversion timeout after 60s")), 60000)
    );

    const blob = await Promise.race([blobPromise, blobTimeoutPromise]);
    debugLog("BookLoader", "Blob created, size:", blob.size, "bytes",
                `(${(blob.size / 1024 / 1024).toFixed(2)} MB)`);

    debugLog("trace", `Blob size: ${blob.size}`);

    debugLog("BookLoader", "Creating File object...");
    const file = new File([blob], "book.epub", { type: "application/epub+zip" });
    debugLog("BookLoader", "File object created successfully");

    return file;
  } catch (err) {
    console.error("[BookLoader] Error loading book from file:", err);
    console.error("[BookLoader] Error stack:", err.stack);
    throw err;
  }
}

  /**
   * Create a custom loader for a directory (extracted EPUB)
   */
  async #makeCustomDirectoryLoader(dirPath) {
  debugLog("BookLoader", "Creating directory loader for:", dirPath);

  if (!dirPath.endsWith('/')) {
    dirPath = dirPath + '/';
  }

  const decoder = new TextDecoder();

  // Load sizes manifest generated by Swift during extraction
  let sizeMap = {};
  try {
    const sizesUrl = new URL('_sizes.json', `file://${dirPath}`);
    const response = await fetch(sizesUrl);
    if (response.ok || response.status === 0) {
      sizeMap = await response.json();
      debugLog("BookLoader", "Loaded sizes manifest:", Object.keys(sizeMap).length, "entries");
    }
  } catch (err) {
    console.warn("[BookLoader] Could not load _sizes.json:", err);
  }

  async function fetchFileAsBlob(filename) {
    try {
      const url = new URL(filename, `file://${dirPath}`);
      debugLog("BookLoader", "Fetching file:", url.href);
      const response = await fetch(url);
      if (!response.ok && response.status !== 0) {
        console.error("[BookLoader] Failed to fetch", filename, "status:", response.status);
        return null;
      }
      return await response.blob();
    } catch (err) {
      console.error("[BookLoader] Error fetching", filename, err);
      return null;
    }
  }

  async function loadText(filename) {
    const blob = await fetchFileAsBlob(filename);
    if (!blob) return null;
    const buffer = await blob.arrayBuffer();
    return decoder.decode(buffer);
  }

  async function loadBlob(filename) {
    return await fetchFileAsBlob(filename);
  }

  function getSize(filename) {
    return sizeMap[filename] ?? 0;
  }

  return { loadText, loadBlob, getSize };
}

  /**
   * Load a book from a directory (extracted EPUB)
   */
  async #loadBookFromDirectory(dirPath) {
  debugLog("BookLoader", "Loading book from directory:", dirPath);
  try {
    debugLog("BookLoader", "Creating custom loader...");
    const loader = await this.#makeCustomDirectoryLoader(dirPath);

    debugLog("BookLoader", "Importing EPUB module...");
    const { EPUB } = await import('./foliate-js/epub.js');

    debugLog("BookLoader", "Creating EPUB instance...");
    const epub = new EPUB(loader);

    debugLog("BookLoader", "Initializing EPUB...");
    const book = await epub.init();

    debugLog("BookLoader", "Book loaded successfully from directory");
    return book;
  } catch (err) {
    console.error("[BookLoader] Error loading book from directory:", err);
    console.error("[BookLoader] Error stack:", err.stack);
    throw err;
  }
}
}
